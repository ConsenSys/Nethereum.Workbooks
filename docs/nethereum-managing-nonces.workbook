---
uti: com.xamarin.workbook
id: 7c6a7c28-9e2c-4536-8cb3-841b6173cacb
title: nethereum-managing-nonces
platforms:
- Console
packages:
- id: Nethereum.Web3
  version: 3.0.0
---

# Managing nonces with Nethereum

This document is a Workbook, find more about workbooks' installation requirements  [here](https://docs.microsoft.com/en-us/xamarin/tools/workbooks/install).

To prevent replay attacks (submitting the same transaction several times) Ethereum provides a transaction counter: the `nonce` parameter. Nonce keeps track of the number of times a transaction has been run by an account.

When making a transaction in Ethereum, a consecutive number should be attached to each transaction on the same account. Each node will process transactions from a specific account in a strict order according to the value of its nonce.

Therefore, failing to increment this value correctly can result in different kinds of errors. For instance, letâ€™s say the latest transaction nonce was 121:

## What are nonces?
The nonce is an important component of a transaction, it is an attribute of a an address that represents the number of transactions that have been sent by that address.
Nonces have two functions:
1- Allowing to choose the order in which order transactions will be executed.
2- Avoiding duplicate attacks.

In case 1, nonces enable to choose the order in which transactions will be executed by simply assigning nonces reflecting the order in which we want them processed (`0`for the first `1` for the second, etc...). 
In case 2, nonces prevent an attacker from copying one of our transactions and resending, a nonce makes a transaction unique, there can only be one single transaction with a specific nonce, once it's written in a block, it cannot be "replayed". 

For more details on transactions and nonces, we recommend [this article](https://github.com/ethereumbook/ethereumbook) (and the [Ethereum Book](https://github.com/ethereumbook/ethereumbook)more generally)

## How Nethereum helps managing nonces

#### Reusing nonce: if we send a new transaction for the same account with a nonce of either 121 or below, the node will reject it.
#### Gaps: if we send a new transaction with a nonce of either 123 or higher, the transaction will not be processed until this gap is closed, i.e. until a transaction with nonce 122 has been processed.
The nonce for the next transaction, can be simply defined as the total number of transactions for that account. The transaction count can be retrieved using `web3.Eth.GetTransactionCount.SendRequestAsync(account, BlockParameter.CreatePending())`. This includes the total number of transactions including the pending transactions, which have been submitted but are yet to be included in the blockchain.

There is a small delay when transactions are included on the pending queue by clients like Geth or Parity. If we rely on the the transaction count, this can be an issue, if we are batching transactions at a faster rate that are included on the pending transaction queue.

To keep nonce count in sync between a Nethereum Dapp and the client it communicates with, Nethereum provides a `NonceService`, which can be assigned to the transaction manager, the default NonceService provides an in memory counter of the number of transactions / nonces.

## Prerequisites:

First, let's download the test chain matching your environment from <https://github.com/nethereum/testchains>

Start a geth chain (geth-clique-linux\\, geth-clique-windows\\ or geth-clique-mac\\) using **startgeth.bat** (windows) or **startgeth.sh** (mac/linux). the chain is setup with the proof of authority consensus and will start the mining process immediately.

```csharp
#r "nethereum.web3"
```

```csharp
#r "nethereum.Accounts"
```

```csharp
using Nethereum.RPC.Eth.Transactions;
```

Then we will need to add `using` statements:

```csharp
using Nethereum.Web3;
using Nethereum.Web3.Accounts;
using Nethereum.Web3.Accounts.Managed;
using Nethereum.Signer;
using Nethereum.Hex.HexConvertors.Extensions;
using Nethereum.KeyStore;
using Nethereum.Hex.HexConvertors;
using Nethereum.Hex.HexTypes;
using Nethereum.RPC.NonceServices;
using Nethereum.RPC.TransactionReceipts;
using System.Threading.Tasks;
using Nethereum.RPC.Eth.Transactions;
using Nethereum.RPC.Eth.DTOs;
```

## Nonce management with Nethereum `accounts` objects

In most cases, Nethereum takes care of incrementing the `nonce` automatically (unless you need to sign a raw transaction manually, we'll explain that in the next chapter).

Once you have loaded your private keys into your account, if Web3 is instantiated with that account all the transactions made using the TransactionManager, Contract deployment or Functions will be signed offline using the latest nonce.

Nonce management is insured whether you are using an `account` or a `managed account` object.

Example:
This example shows what happens to the `nonce` value when we send a transaction with a Nethereum account.
We first need to create an instance of an account, then use it to
instantiate a `web3` object.

Let's first declare our new `Account`:

```csharp
var privateKey = "0xb5b1870957d373ef0eeffecc6e4812c0fd08f554b37b233526acc331bf1544f7";
var account = new Nethereum.Web3.Accounts.Account(privateKey);
```

* `web3` is the Web3 instance using the new `account` as constructor

```csharp
var web3 = new Web3(account);
```

Let's now examine what happens to the `nonce` value before and after we send a transaction:

### Before a transaction is sent:

Nethereum `Account` objects also provide with a `NonceService` that  keeps track of all transactions, including the ones still pending, making it easy to assign the right nonce to a transaction about to be sent.

Here is how to return the current number of transaction for the `account` we declared earlier:

```csharp
//var nonceProvider = account.NonceService;
```

It is also possible to return the next nonce that needs to be assigned to a future transaction, this nonce will be defined using the current nonce plus the pending transactions sent by our account:

```csharp
var futureNonce = await account.NonceService.GetNextNonceAsync();
```

Now, let's send a simple transaction, the right nonce will be automatically assigned to it by the `TransactionManager`:

```csharp
var recipientAddress = "0xde0b295669a9fd93d5f28d9ec85e40f4cb697bae";
var transaction = await web3.TransactionManager.SendTransactionAsync(account.Address, recipientAddress, new HexBigInteger(1));
```

Nethereum's `TransactionManager` uses `NonceService` to retrieve the relevant nonce for the

#### After a transaction has been sent

Finally, using the NonceService, we can check if our transaction count has changed:

```csharp
var currentNonce1 = account.NonceService;
```

As the above code demonstrates, the `nonce` was automatically incremented, thanks to the use of `TransactionManager`.

Nevertheless are scenarios where we might want to supply a Nonce manually, for example if we want to sign a transaction completely offline.

## Sending a transaction with an arbitrary nonce

The below shows how to verify the number of transactions performed from an account and

Let's first create an object instance of `TransactionSigner`

```csharp
var OfflineTransactionSigner = new TransactionSigner();
```

Before executing the below, make sure you restart your devchain by exiting the running instance and launching using `startgeth` (for geth client) or `launch` (for parity).

First, let's check again what the current nonce is (if you duly restarted your chain, this should return `0`).

```csharp
var currentNonce2 = account.NonceService;
```

We can now determine what should be the next nonce for our upcoming transaction:

```csharp
var manualNonce = await nonceProvider.GetNextNonceAsync();
```

We can now sign our transaction offline:

```csharp
var encoded = OfflineTransactionSigner.SignTransaction(privateKey, recipientAddress, 10,
                manualNonce);
```

And finally, send our transaction:

```csharp
var txId = await web3.Eth.Transactions.SendRawTransaction.SendRequestAsync("0x" + encoded);
```
