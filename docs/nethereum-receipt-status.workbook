---
uti: com.xamarin.workbook
id: 92040ff5-c871-4144-af7c-be7db00abbd7
title: nethereum-receipt-status
platforms:
- Console
packages:
- id: Nethereum.Web3
  version: 3.0.0
---

# Using Receipt Status

This document is a Workbook, find more about workbooks' installation requirements  [here](https://docs.microsoft.com/en-us/xamarin/tools/workbooks/install).

Since the Bizantium fork, Ethereum provides with a way to know if a transaction succeeded by checking its receipt `status`. A receipt status can have a value of `0` or `1`, `0` meaning that the transaction has failed (whatever the reason may be) `1` meaning the transaction was succesful.

## How Nethereum helps managing nonces

## Prerequisites:

First, let's download the test chain matching your environment from <https://github.com/nethereum/testchains>

Start a geth chain (geth-clique-linux\\, geth-clique-windows\\ or geth-clique-mac\\) using **startgeth.bat** (windows) or **startgeth.sh** (mac/linux). the chain is setup with the proof of authority consensus and will start the mining process immediately.

```csharp
#r "nethereum.web3"
```

```csharp
#r "nethereum.Accounts"
```

```csharp
using Nethereum.RPC.Eth.Transactions;
```

Then we will need to add `using` statements:

```csharp
using Nethereum.Web3;
using Nethereum.Web3.Accounts;
using Nethereum.Web3.Accounts.Managed;
using Nethereum.Signer;
using Nethereum.Hex.HexConvertors.Extensions;
using Nethereum.KeyStore;
using Nethereum.Hex.HexConvertors;
using Nethereum.Hex.HexTypes;
using Nethereum.RPC.NonceServices;
using Nethereum.RPC.TransactionReceipts;
using System.Threading.Tasks;
using Nethereum.RPC.Eth.Transactions;
using Nethereum.RPC.Eth.DTOs;
```

## Nonce management with Nethereum `accounts` objects

In most cases, Nethereum takes care of incrementing the `nonce` automatically (unless you need to sign a raw transaction manually, we'll explain that in the next chapter).

Once you have loaded your private keys into your account, if Web3 is instantiated with that account all the transactions made using the TransactionManager, Contract deployment or Functions will be signed offline using the latest nonce.

Nonce management is insured whether you are using an `account` or a `managed account` object.

Example:
This example shows what happens to the `nonce` value when we send a transaction with a Nethereum account.
We first need to create an instance of an account, then use it to
instantiate a `web3` object.

Let's first declare our new `Account`:

```csharp
var privateKey = "0xb5b1870957d373ef0eeffecc6e4812c0fd08f554b37b233526acc331bf1544f7";
var account = new Nethereum.Web3.Accounts.Account(privateKey);
```

* `web3` is the Web3 instance using the new `account` as constructor

```csharp
var web3 = new Web3(account);
```

Let's now examine what happens to the `nonce` value before and after we send a transaction:

### Before a transaction is sent:

Nethereum `Account` objects also provide with a `NonceService` that  keeps track of all transactions, including the ones still pending, making it easy to assign the right nonce to a transaction about to be sent.

Here is how to return the current number of transaction for the `account` we declared earlier:

```csharp
//var nonceProvider = account.NonceService;
```

It is also possible to return the next nonce that needs to be assigned to a future transaction, this nonce will be defined using the current nonce plus the pending transactions sent by our account:

```csharp
var futureNonce = await account.NonceService.GetNextNonceAsync();
```

Now, let's send a simple transaction, the right nonce will be automatically assigned to it by the `TransactionManager`:

```csharp
var recipientAddress = "0xde0b295669a9fd93d5f28d9ec85e40f4cb697bae";
var transaction = await web3.TransactionManager.SendTransactionAsync(account.Address, recipientAddress, new HexBigInteger(1));
```

Nethereum's `TransactionManager` uses `NonceService` to retrieve the relevant nonce for the

#### After a transaction has been sent

Finally, using the NonceService, we can check if our transaction count has changed:

```csharp
var currentNonce1 = account.NonceService;
```

As the above code demonstrates, the `nonce` was automatically incremented, thanks to the use of `TransactionManager`.

Nevertheless are scenarios where we might want to supply a Nonce manually, for example if we want to sign a transaction completely offline.

## Sending a transaction with an arbitrary nonce

The below shows how to verify the number of transactions performed from an account and

Let's first create an object instance of `TransactionSigner`

```csharp
var OfflineTransactionSigner = new TransactionSigner();
```

Before executing the below, make sure you restart your devchain by exiting the running instance and launching using `startgeth` (for geth client) or `launch` (for parity).

First, let's check again what the current nonce is (if you duly restarted your chain, this should return `0`).

```csharp
var currentNonce2 = account.NonceService;
```

We can now determine what should be the next nonce for our upcoming transaction:

```csharp
var manualNonce = await nonceProvider.GetNextNonceAsync();
```

We can now sign our transaction offline:

```csharp
var encoded = OfflineTransactionSigner.SignTransaction(privateKey, recipientAddress, 10,
                manualNonce);
```

And finally, send our transaction:

```csharp
var txId = await web3.Eth.Transactions.SendRawTransaction.SendRequestAsync("0x" + encoded);
```
