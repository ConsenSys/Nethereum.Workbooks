---
uti: com.xamarin.workbook
id: e5cc8ec1-5a9d-4ff2-b229-a7c1d489a8ca
title: nethereum-signing-messages
platforms:
- Console
packages:
- id: Assert
  version: 4.2.1
- id: Nethereum.Web3
  version: 2.0.1
---

# Signing messages with Nethereum

Nethereum allows you to sign any type of data using Ethereum signature format. The following is a quick guide to signing online and offline with Nethereum.

First, we need to set our environment:

## Prerequisites:

First, let's download the test chain matching your environment from <https://github.com/Nethereum/Testchains>

Start a Geth chain (geth-clique-linux\\, geth-clique-windows\\ or geth-clique-mac\\) using **startgeth.bat** (Windows) or **startgeth.sh** (Mac/Linux). The chain is setup with the Proof of Authority consensus and will start the mining process immediately.

We then need to add Nethereum's Nuget package:

```csharp
#r "Nethereum.Web3"
```

After that, we will need to add `using` statements:

```csharp
using Nethereum.Web3;
using Nethereum.Web3.Accounts;
using Nethereum.Web3.Accounts.Managed;
using Nethereum.Signer;
using Nethereum.KeyStore;
```

## offline message signing 

Signing a message offline allows to certify that a piece of data was signed by a specific sending account. A signed message proves the origin of a message without revealing the private key of its signer account.

The below shows how to sign an arbitrary `string`:

`address` declares the sender's address

```csharp
var address = "0x12890d2cce102216644c59dae5baed380d84830c";
```

`msg` declares the content of the message itself, here it's a simple string.

```csharp
var msg = "wee test message 18/09/2017 02:55PM";
```

`privatekey` declares the sender's address

```csharp
var privateKey = "0xb5b1870957d373ef0eeffecc6e4812c0fd08f554b37b233526acc331bf1544f7";
```

`signer` creates an instance of the `EthereumMessageSigner` object:

```csharp
var signer = new EthereumMessageSigner();
```

`signature` evaluates to the signature itself: a string

```csharp
var signature = signer.EncodeUTF8AndSign(msg, new EthECKey(privateKey));
```

`addressRec` evaluates to the signer's address

```csharp
var addressRec = signer.EncodeUTF8AndEcRecover(msg, signature);
```

## Offline transaction signing

"OfflineTransactionSigning" allows you to sign transactions, get the sender address or verify already signed transactions without interacting directly with the client. This is very convenient as light clients may not be able to store the whole chain, but would prefer to use their privates keys to sign transactions and broadcast the signed raw transaction to the network.

Here are the methods available through OfflineTransactionSigning:
`web3.OfflineTransactionSigning.SignTransaction`
`web3.OfflineTransactionSigning.GetSenderAddress`
`web3.OfflineTransactionSigning.VerifyTransaction`

To sign a transaction offline in Nethereum you can do the following:

First, you will need your private key, and sender address. You can retrieve the sender address from your private key using

```csharp
var privateKey = "0xb5b1870957d373ef0eeffecc6e4812c0fd08f554b37b233526acc331bf1544f7";
var senderAddress = Nethereum.Signer.EthECKey.GetPublicAddress(privateKey);
```

Now using web3 first you will need to retrieve the total number of transactions of your sender address (check the \`value\` parameter of the returned txCount object)

```csharp
var web3 = new Web3(); 
var txCount = await web3.Eth.Transactions.GetTransactionCount.SendRequestAsync(senderAddress);
```

The txCount will be used as the nonce to sign the transaction.

Now using web3 again, you can build an encoded transaction as following:

```csharp
var recipientAddress = "0xde0b295669a9fd93d5f28d9ec85e40f4cb697bae";
var encoded =  Web3.OfflineTransactionSigner.SignTransaction(privateKey, recipientAddress, 10, txCount.Value);
```

If you need to include the data and gas there are overloads for it.

You can verify an encoded transaction:

```csharp
Assert.True(web3.OfflineTransactionSigning.VerifyTransaction(encoded));
```

Or get the sender address from an encoded transaction:

```csharp
web3.OfflineTransactionSigning.GetSenderAddress(encoded);
```

To send the encoded transaction you will use the RPC method "SendRawTransaction"

```csharp
var txId = await web3.Eth.Transactions.SendRawTransaction.SendRequestAsync("0x" + encoded);
```

### Transaction Request To Offline Signed Transaction Interceptor

The web3 transaction request to an offline signed transaction interceptor provides a mechanism to intercept all transactions and automatically offline sign them and send a raw transaction with a preconfigured private key.

```csharp
  var privateKey = "0xb5b1870957d373ef0eeffecc6e4812c0fd08f554b37b233526acc331bf1544f7";
  var senderAddress = "0x12890d2cce102216644c59daE5baed380d84830c";
```

```csharp
  var web3 = new Web3();
  var transactionInterceptor = new TransactionRequestToOfflineSignedTransactionInterceptor(senderAddress, privateKey, web3);
  web3.Client.OverridingRequestInterceptor = transactionInterceptor;
```

The interceptor requires the private key, the corresponding address and an instance of web3. Once the web3 rpc client is configured all the requests will be the same.

```csharp
    var txId = await web3.Eth.DeployContract.SendRequestAsync(abi, contractByteCode, senderAddress, new HexBigInteger(900000), 7);
```

```csharp
#r "Assert"
```
