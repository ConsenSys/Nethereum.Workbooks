---
packages:
- id: Nethereum.Web3
  version: 2.4.0
uti: com.xamarin.workbook
id: 4e0b3afb-0940-4d51-9f9b-e4baeb5714d4
title: Nethereum-ChainID-Management
platforms:
- Console
---

```csharp
#r "Nethereum.Web3"
```

```csharp
#r "Nethereum.Accounts"
```

```csharp
#r "Nethereum.Signer"
```

```csharp
#r "Nethereum.RPC"
```

```csharp
#r "Nethereum.Hex"
```

```csharp
using Nethereum.Web3; using Nethereum.Signer; using Nethereum.Web3.Accounts; using Nethereum.Util; using Nethereum.Hex.HexConvertors.Extensions; using Nethereum.RPC.Eth.DTOs; using Nethereum.Hex.HexTypes;
```

# Chain ID management for replay attack protection

This workbook explains what a replay attack is and how Nethereum allows you to protect your code against them.

## Replay Attack

Ethereum makes it possible to send the same transaction across different chains, hence the term "replay attack". For instance, it is possible to issue a fund transfer on a testchain and then
perform the same transfer over the MainNet (with real funds). This vulnerability is due to the fact that the same accounts can exist in any Ethereum chain, protected by the same privateKey.

To counteract this issue, an Ethereum fix was implemented (the improvement name is [EIP155](https://github.com/Nethereum/Nethereum.Workbooks/issues/10)) allowing the insertion of the ChainID data in signed transactions. Thanks to this improvement it is now possible to force a transaction to only run on a specific chain by including its ID when signed.

The preconfigured chainIds can be found in Nethereum.Signer.Chain:

![](screenshots/Nethereum-ChainID-Management-1.jpg)

To configure the chainId in geth, edit the genesis as follows (example configuration):

![](screenshots/Nethereum-ChainID-Management-2.jpg)

To sign a transaction using the ChainID attribute, we need to create an instance of the "Account" object using our private key and ChainID as arguments.

First, we need to declare our private key:

```csharp
var privatekey = "0xb5b1870957d373ef0eeffecc6e4812c0fd08f554b37b233526acc331bf1544f7";
```

Then we can create an Account instance as follows:

```csharp
var account = new Account(privatekey, 444444444500);
```

or as such:

```csharp
account =Â  new Account(privatekey, 444444444500);
```

Using our new account, let's simplify our interactions with Ethereum by creating a Web3 instance:

```csharp
var web3 = new Web3(account);
```

Let's  now create a recipient address for our transaction:

```csharp
var toAddress = await web3.Personal.NewAccount.SendRequestAsync("password");
```

Finally let's just transfer some Ether using the transaction manager. The transaction will be signed and sent using our private key.

```csharp
var wei = Web3.Convert.ToWei(1);
```

```csharp
 var transactionReceipt = await web3.TransactionManager.TransactionReceiptService.SendRequestAndWaitForReceiptAsync(
               new TransactionInput() {From = account.Address, To = toAddress, Value = new HexBigInteger(wei)}, null);
```

Now, we can check if the balance of the recipient account has increased:

```csharp
 var balance = await web3.Eth.GetBalance.SendRequestAsync("0x12890d2cce102216644c59dae5baed380d84830c");
```
